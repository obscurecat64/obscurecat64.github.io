{"componentChunkName":"component---src-templates-blog-post-js","path":"/functional-components-inside-render-bad/","result":{"data":{"site":{"siteMetadata":{"title":"Wai Thoughts"}},"markdownRemark":{"id":"7fbaaef6-63a6-5c3f-83b1-179e7cc20d57","excerpt":"For this post I’d to share why you should probably not define (and use) functional components inside . So let’s start by asking ourselves if it is okay to write…","html":"<p>For this post I’d to share why you should probably not define (and use) functional components inside <code class=\"language-text\">render()</code>.</p>\n<p>So let’s start by asking ourselves if it is okay to write code like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const App = () => {\n const renderContentA = () => &lt;div>Content A&lt;/div>\n\n return (\n  &lt;div>\n    {renderContentA()}\n  &lt;/div>\n )\n}</code></pre></div>\n<p>So this works fine; we define a function <code class=\"language-text\">renderContentA</code> and to be invoked in the return statement to retrieve some <code class=\"language-text\">JSX.Element</code>s. When this could be helpful is when we want to conditionally render some content:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const App = () => {\n const renderContentA = () => &lt;div>Content A&lt;/div>\n const renderContentB = () => &lt;div>Content B&lt;/div>\n\n return (\n  &lt;div>\n    {Math.random > 0.5 ? renderContentA() : renderContentB()}\n  &lt;/div>\n )\n}</code></pre></div>\n<p>You could do this too:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const App = () => {\n return (\n  &lt;div>\n    {Math.random > 0.5 ? &lt;div>Content A&lt;/div> : &lt;div>Content B&lt;/div>}\n  &lt;/div>\n )\n}</code></pre></div>\n<p>But sometimes for code readability reasons you might want the former.</p>\n<p>So… it is totally okay to define functions that return <code class=\"language-text\">JSX.Element</code>s in a component, but what about the following?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const App = () => {\n const ComponentA = () => &lt;div>Content A&lt;/div>\n\n return (\n  &lt;div>\n    &lt;ComponentA />\n  &lt;/div>\n )\n}</code></pre></div>\n<p>At first glance, they might look quite similar. <code class=\"language-text\">renderContentA</code> is now renamed to <code class=\"language-text\">ComponentA</code>, but that’s just a name change. The real difference is in the return statement where instead of <code class=\"language-text\">renderContentA()</code> it is now <code class=\"language-text\">&lt;ComponentA /></code>. And it is a huge difference!</p>\n<p>We first need to understand what <code class=\"language-text\">&lt;ComponentA /></code> means. From the React docs:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Fundamentally, JSX just provides syntactic sugar for the React.createElement(component, props, …children) function.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>We can see this by pasting the code into <a href=\"https://babeljs.io\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Babel</a>, it is compiled down to:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const App = () => {\n  const ComponentA = () => /*#__PURE__*/React.createElement(\"div\", null, \"Content A\");\n\n  return /*#__PURE__*/React.createElement(\n    \"div\",\n    null, \n    /*#__PURE__*/React.createElement(ComponentA, null)\n  );\n};</code></pre></div>\n<p>Let’s look at what’s different between the 2 renders. An important thing to note here is that in each render, <code class=\"language-text\">ComponentA</code> is recreated. That means that between the two renders, the <strong>identity</strong> of <code class=\"language-text\">ComponentA</code> is not stable, that is <code class=\"language-text\">ComponentA</code> in the first render is <code class=\"language-text\">!==</code> <code class=\"language-text\">ComponentA</code> in the second render. Why is that so? That’s just how Javascript works!</p>\n<p>Now, during the <a href=\"https://reactjs.org/docs/reconciliation.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">reconcillation</a> phase, React attempts to figure out what has changed between the 2 renders in order to update the UI to the most recent tree (of React elements from the latest render). What we have to know here is that for <a href=\"https://reactjs.org/docs/reconciliation.html#elements-of-different-types\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">elements of different types</a>, React will tear down the old tree and build the new tree from scratch. As we’ve discussed, since our <code class=\"language-text\">ComponentA</code>’s identity is not stable, React <strong>will</strong> treat it as they are elements of different types, and build the new tree from scratch. That is why you really shouldn’t do this.</p>\n<p>To fix this we can simply lift the definition of <code class=\"language-text\">ComponentA</code> out of <code class=\"language-text\">App</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const ComponentA = () => &lt;div>Content A&lt;/div>\n\nconst App = () => {\n return (\n  &lt;div>\n    &lt;ComponentA />\n  &lt;/div>\n )\n}</code></pre></div>\n<p>This makes sense because <code class=\"language-text\">ComponentA</code> is created once and not on every render of <code class=\"language-text\">App</code>. This way, in every render of <code class=\"language-text\">App</code>, React knows that they are elements of the same type.</p>\n<p>With this, let’s look at the result from Babel when using <code class=\"language-text\">renderContentA()</code> instead of <code class=\"language-text\">&lt;ComponentA /></code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const App = () => {\n  const renderContentA = () => /*#__PURE__*/React.createElement(\"div\", null, \"Content A\");\n\n  return /*#__PURE__*/React.createElement(\"div\", null, renderContentA());\n};</code></pre></div>\n<p>Notice that no <code class=\"language-text\">React.createElement(ComponentA, ...)</code> or the likes of it is formed here. This is why we do not get the same issue as when using <code class=\"language-text\">&lt;ComponentA /></code>.</p>\n<p>I’d also like to add that this does not only affect performance. I provided this example <a href=\"https://codesandbox.io/s/optimistic-ully-z92j1?from-embed\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a> to demonstrate how you can lose state when defining functional components inside render.</p>\n<p>First, try incrementing <code class=\"language-text\">ComponentA</code>’s state via <code class=\"language-text\">Component A button</code> and have <code class=\"language-text\">App</code> rerender by clicking on <code class=\"language-text\">App button</code>. You should see that the state of <code class=\"language-text\">ComponentA</code> is lost everytime <code class=\"language-text\">App</code> rerenders. When the old tree is torn down, its state is lost too.</p>\n<p>Now, try lifting <code class=\"language-text\">ComponentA</code> out of <code class=\"language-text\">App</code>. You should now see that the state is preserved when <code class=\"language-text\">App</code> rerenders, which is what we expect!</p>\n<p>And that’s all I have to share for today! It was for me, quite interesting experimenting with the different results and behaviour between invoking a function (<code class=\"language-text\">renderContentA()</code>) and using JSX (<code class=\"language-text\">&lt;ComponentA /></code>).</p>\n<p>If you’ve reach here I thank you very much and I hope you learnt something from this too! If you noticed an error in my explanation or any gaps in my understanding, or if you simply have some feedback, feel free to drop me an email at <a href=\"mailto:wailun22b@gmail.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">wailun22b@gmail.com</a>.</p>\n<p>Thanks and check back soon again!</p>","frontmatter":{"title":"Functional components inside render?","date":"January 20, 2022","description":null,"tags":["tech","react"]}},"previous":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"Hello World!"}},"next":{"fields":{"slug":"/global-state-hook/"},"frontmatter":{"title":"A global state hook"}}},"pageContext":{"id":"7fbaaef6-63a6-5c3f-83b1-179e7cc20d57","previousPostId":"8413646e-9508-5c3b-92a1-030ce0bfcc89","nextPostId":"b84d9d3e-a37e-5625-a633-a398732e6c4b"}},"staticQueryHashes":["3000541721","3274528899"]}