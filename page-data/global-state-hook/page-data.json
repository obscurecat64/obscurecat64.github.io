{"componentChunkName":"component---src-templates-blog-post-js","path":"/global-state-hook/","result":{"data":{"site":{"siteMetadata":{"title":"Wai Thoughts"}},"markdownRemark":{"id":"b84d9d3e-a37e-5625-a633-a398732e6c4b","excerpt":"My goal was to have 12 posts by the end of the year (a post a month) but obviously I havenâ€™t been posting in a long time ðŸ˜…. But thereâ€™s still some time leftâ€¦","html":"<p>My goal was to have 12 posts by the end of the year (a post a month) but obviously I havenâ€™t been posting in a long time ðŸ˜…. But thereâ€™s still some time left, and Iâ€™ll make up for it in the remaining months!</p>\n<p>For this post Iâ€™d like to share about how to write a simple global state hook. Using the hook would look something like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// createGlobalHook is a function that creates a react hook\nconst useGlobalCount = createGlobalHook(0)\nconst useGlobalFlag = createGlobalHook(false)\n\nconst MyComponentA = () => {\n  // component has access to the states via their respective hooks\n  const [globalCount, setGlobalCount] = useGlobalCount()\n  const [globalFlag, setGlobalFlag] = useGlobalFlag()\n\n  // ...\n}</code></pre></div>\n<p>I first saw the idea of such a global state hook while reading through code at work, and while doing some research I found <a href=\"https://github.com/dai-shi/react-hooks-global-state\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">react-hooks-global-state</code></a> and then <a href=\"https://github.com/pmndrs/zustand\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">zustand</code></a> that uses this same idea. <code class=\"language-text\">react-hooks-global-state</code> is actually implemented with <code class=\"language-text\">zustand</code> now (both libraries are written by the same author), and would I recommend you try out <code class=\"language-text\">zustand</code> if youâ€™re interested in such a hook. It deals with more complicated stuffs like React concurrency which for this simple example hook I will not delve into. Disclaimer: I havenâ€™t gotten to using <code class=\"language-text\">zustand</code> just yet (I will soon)!</p>\n<p>Now letâ€™s look at how we could implement a simplified version of such a hook. <code class=\"language-text\">createGlobalHook</code> is a function that accepts an initial state and returns a custom react hook. In it, we need to maintain state which is our new global state. Whenever our global state is updated, we need to inform components that use this state to rerender so as to use the updated state.</p>\n<p>Firstly, in <code class=\"language-text\">createGlobalHook</code> we initialise a variable <code class=\"language-text\">state</code> to <code class=\"language-text\">initialState</code> and create an initially empty array of <code class=\"language-text\">listeners</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const createGlobalHook = (initialState) => {\n  let state = initialState\n  const listeners = []\n\n  // ...\n}</code></pre></div>\n<p>Then, we start writing our custom hook <code class=\"language-text\">useGlobalState</code>. In <code class=\"language-text\">useGlobalState</code>, we will use Reactâ€™s built-in <code class=\"language-text\">useState</code> hook for its <code class=\"language-text\">setState</code> function. We talked about how we need to inform components to rerender when the state is changed, and by using <code class=\"language-text\">setState</code> React will rerender the component when <code class=\"language-text\">setState</code> is called with a new state. To do so, we add a new listener to <code class=\"language-text\">listeners</code> when the component is mounted to inform the component to rerender when state changes. When the component is unmounted, we unsubscribe it as a listener.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const createGlobalHook = (initialState) => {\n  let state = initialState\n  const listeners = []\n\n  const useGlobalState = () = {\n    const [, setState] = useState(state)\n\n    useEffect(() => {\n      const listener = () => setState(state)\n      listeners.push(listener)\n\n      // remove listener from listeners when component unmounts\n      return () => listeners.splice(listeners.indexOf(listener), 1)\n    }, [])\n\n    // ...\n  }\n\n  return useGlobalState\n}\n</code></pre></div>\n<p>We need to have a custom <code class=\"language-text\">setGlobalState</code> function that updates the global state. When doing so, we get the current and other components to rerender by going through our <code class=\"language-text\">listeners</code>. We wrap <code class=\"language-text\">setGlobalState</code> in a <code class=\"language-text\">useCallback</code> to ensure that it is stable across rerenders, just like <code class=\"language-text\">setState</code> from the <code class=\"language-text\">useState</code> hook. Lastly, we return <code class=\"language-text\">state</code> (which is our global state) and <code class=\"language-text\">setGlobalState</code> just like the <code class=\"language-text\">useState</code> hook.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const createGlobalHook = (initialState) => {\n  let state = initialState\n  const listeners = []\n\n  const useGlobalState = () = {\n    const [, setState] = useState(state)\n\n    useEffect(() => {\n      const listener = () => setState(state)\n      listeners.push(listener)\n\n      // remove listener from listeners when component unmounts\n      return () => listeners.splice(listeners.indexOf(listener), 1)\n    }, [])\n\n    const setGlobalState = useCallback((newState) => {\n      state = newState\n      setState(newState)\n      listeners.forEach((listener) => listener())\n    }, [])\n\n    return [state, setGlobalState]\n  }\n\n  return useGlobalState\n}\n</code></pre></div>\n<p>Now letâ€™s run through what happens when a component uses <code class=\"language-text\">createGlobalHook</code> and its returned hook:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const useGlobalCount = createGlobalHook(0)\n\nconst Counter = () => {\n  const [globalCount, setGlobalCount] = useGlobalCount()\n\n  useEffect(() => {\n    console.log('Rendered')\n  })\n\n  return (\n    &lt;div>\n      &lt;button onClick={() => setGlobalCount(globalCount + 1)}>Click me&lt;/button>\n      count: {globalCount}\n    &lt;/div>\n  )\n}\n\nconst App = () => {\n  return (\n    &lt;div>\n      &lt;Counter />\n      &lt;Counter />\n    &lt;/div>\n  )\n}</code></pre></div>\n<p><code class=\"language-text\">createGlobalHook</code> is called, and an initial state is initialised with a value of 0. The returned hook <code class=\"language-text\">useGlobalCount</code> is used in the <code class=\"language-text\">Counter</code> component.</p>\n<p>We create a <code class=\"language-text\">useGlobalCount</code> hook using <code class=\"language-text\">createGlobalHook</code>. Now in the <code class=\"language-text\">Counter</code> component, we use our new <code class=\"language-text\">useGlobalCount</code> hook. The component will show the value of <code class=\"language-text\">globalCount</code>, as well as call <code class=\"language-text\">setGlobalCount</code> to increment its value when the button is clicked.</p>\n<p>When <code class=\"language-text\">App</code> is rendered, so are our 2 <code class=\"language-text\">Counter</code> components. By using the <code class=\"language-text\">useGlobalCount</code> hook, they are each registered as a listener in <code class=\"language-text\">listeners</code>. When the button in the first <code class=\"language-text\">Counter</code> is clicked, the global state is updated and the components that use <code class=\"language-text\">useGlobalCount</code> are informed to rerender. Since all components that read <code class=\"language-text\">globalCount</code> are rerendered, they will now use (and show) the updated value.</p>\n<p>I created a small working example <a href=\"https://codesandbox.io/s/peaceful-jang-7dczdu?file=/src/createGlobalHook.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a> if youâ€™d like to see it in action! With Concurrent React a basic implementation like this can result in undesired behaviour such as <a href=\"https://stackoverflow.com/questions/54891675/what-is-tearing-in-the-context-of-the-react-redux\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tearing</a>, and so using a global state management library that handles them for you might be more practical. Still, itâ€™s interesting to see how things work underneath!</p>\n<p>If you havenâ€™t seen a hook like this, I hope this post was helpful to you ðŸ˜„. Thatâ€™s all for this post; check back again soon and see ya!</p>","frontmatter":{"title":"A global state hook","date":"August 28, 2022","description":null,"tags":["tech","react"]}},"previous":{"fields":{"slug":"/functional-components-inside-render-bad/"},"frontmatter":{"title":"Functional components inside render?"}},"next":{"fields":{"slug":"/so-you-want-to-vim/"},"frontmatter":{"title":"So you want to Vim"}}},"pageContext":{"id":"b84d9d3e-a37e-5625-a633-a398732e6c4b","previousPostId":"7fbaaef6-63a6-5c3f-83b1-179e7cc20d57","nextPostId":"a4706c71-f00f-5482-9473-1c299072dc3d"}},"staticQueryHashes":["3000541721","3274528899"]}